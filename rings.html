<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>AR Try-On v26 (Occlusion + Scale + Shift)</title>
    <style> body { margin: 0; padding: 0; overflow: hidden; background-color: #000; font-family: sans-serif; } #input_video { position: absolute; top: 0; left: 0; width: 100%; height: 100%; object-fit: cover; z-index: 0; } #output_canvas { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 1; pointer-events: none; } #ui-container { position: absolute; bottom: 30px; left: 0; width: 100%; display: flex; justify-content: center; align-items: center; z-index: 10; gap: 20px; } /* Кнопки переключения моделей */ .arrow-btn { border: none; border-radius: 50%; width: 50px; height: 50px; font-size: 24px; display: flex; align-items: center; justify-content: center; box-shadow: 0 4px 10px rgba(0,0,0,0.5); cursor: pointer; } /* Кнопка фото */ .camera-btn { width: 70px; height: 70px; border-radius: 50%; border: 4px solid white; background-color: rgba(13, 42, 87, 0.85); position: relative; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.5); display: flex; align-items: center; justify-content: center; } .camera-btn::after { content: ''; width: 55px; height: 55px; background-color: white; border-radius: 50%; transition: transform 0.1s; } .camera-btn:active::after { transform: scale(0.9); background-color: #ddd; } /* Кнопки размера */ .scale-btn { color: white; border: 2px solid white; border-radius: 50%; width: 40px; height: 40px; font-size: 20px; font-weight: bold; display: flex; align-items: center; justify-content: center; cursor: pointer; box-shadow: 0 4px 10px rgba(0,0,0,0.5); } .scale-btn:active { } #loading-text { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 16px; z-index: 5; padding: 15px 25px; border-radius: 30px; text-align: center; pointer-events: none; } #flash { position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0; pointer-events: none; z-index: 20; transition: opacity 0.2s; } </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/examples/": "https://unpkg.com/three@0.128.0/examples/"
            }
        }
    </script>
</head>
<body>
    <div id="loading-text">Kamera başlatılıyor...<br>Elini göster (Покажи руку)</div>
    <div id="flash"></div>
    <video id="input_video" playsinline muted autoplay></video>
    <canvas id="output_canvas"></canvas>

    <div id="ui-container">
        <!-- Кнопка уменьшения -->
        <button class="scale-btn" id="scale-down">-</button>
        
        <button class="arrow-btn" id="prev-btn">◀</button>
        <div class="camera-btn" id="camera-btn"></div>
        <button class="arrow-btn" id="next-btn">▶</button>
        
        <!-- Кнопка увеличения -->
        <button class="scale-btn" id="scale-up">+</button>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/examples/jsm/loaders/GLTFLoader.js';
        import { RoomEnvironment } from 'three/examples/jsm/environments/RoomEnvironment.js';

        const models = ['ring_01.glb', 'ring_02.glb', 'ring_03.glb'];
        
        const videoElement = document.getElementById('input_video');
        const canvasElement = document.getElementById('output_canvas');
        const loadingText = document.getElementById('loading-text');

        let currentModelIndex = 0;
        let currentRing = null;

        // --- ПЕРЕМЕННЫЕ ---
        // Сдвиг (Offset X увеличил для сдвига вправо)
        const OFFSET_Y = 0.45;  
        const OFFSET_X = 0.32;  // Было 0.05
        const OFFSET_Z = -5.0; 

        // Масштаб
        let ringScale = 10.0; // Базовый размер кольца

        const scene = new THREE.Scene();
        const camera3D = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera3D.position.z = 2;

        const renderer = new THREE.WebGLRenderer({ canvas: canvasElement, alpha: true, antialias: true, preserveDrawingBuffer: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.outputEncoding = THREE.sRGBEncoding;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
        dirLight.position.set(0, 5, 5);
        scene.add(dirLight);

        // --- ОККЛЮДЕР (НЕВИДИМЫЙ ПАЛЕЦ) ---
        // Используем те же размеры, что подобрали ранее (0.33 толщина)
        const occlusionGeo = new THREE.CylinderGeometry(0.33, 0.33, 3.0, 32);
        
        // ВАЖНО: colorWrite: false делает объект невидимым, но он пишет в буфер глубины.
        // Это заставляет всё, что находится ЗА ним (задняя стенка кольца), не рисоваться.
        const occlusionMat = new THREE.MeshBasicMaterial({ colorWrite: false }); 
        
        const occluder = new THREE.Mesh(occlusionGeo, occlusionMat);
        occluder.renderOrder = 0; // Рисуем первым (маску)
        scene.add(occluder);

        const loader = new GLTFLoader();
        function loadRing(index) {
            if (currentRing) { scene.remove(currentRing); currentRing = null; }
            loader.load(models[index], (gltf) => {
                currentRing = gltf.scene;
                currentRing.scale.set(ringScale, ringScale, ringScale);
                currentRing.renderOrder = 1; // Рисуем вторым (кольцо)
                scene.add(currentRing);
            });
        }
        loadRing(0);

        const hands = new window.Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });

        let textHidden = false;

        hands.onResults((results) => {
            renderer.clear();
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                if (!textHidden) { loadingText.style.display = 'none'; textHidden = true; }
                
                const landmarks = results.multiHandLandmarks[0];
                const pBase = landmarks[9]; 
                const pJoint = landmarks[10]; 

                const dx = pJoint.x - pBase.x;
                const dy = pJoint.y - pBase.y;
                const angle = Math.atan2(dy, dx); 

                const x = (pBase.x + pJoint.x) / 2;
                const y = (pBase.y + pJoint.y) / 2;
                
                const screenX = (x - 0.5) * 10 + OFFSET_X; 
                const screenY = -(y - 0.5) * 10 + OFFSET_Y;
                const screenZ = OFFSET_Z; 

                // Обновляем окклюдер
                occluder.position.set(screenX, screenY, screenZ);
                occluder.rotation.z = angle - Math.PI / 3;
                occluder.rotation.x = 0.4; 
                occluder.rotation.y = 0.4; 

                
                // Масштабируем окклюдер пропорционально кольцу
                // Базовый масштаб окклюдера был 1. Если кольцо увеличивается, палец внутри тоже должен "толстеть",
                // чтобы продолжать скрывать заднюю стенку большего кольца.
                const scaleFactor = ringScale / 8.0; 
                occluder.scale.set(scaleFactor, 1, scaleFactor); // Y не трогаем (длину)

                if (currentRing) {
                    currentRing.position.copy(occluder.position);
                    currentRing.rotation.copy(occluder.rotation);
                    // Применяем текущий масштаб
                    currentRing.scale.set(ringScale, ringScale, ringScale);
                }
            }
            renderer.render(scene, camera3D);
        });

        const camera = new window.Camera(videoElement, {
            onFrame: async () => await hands.send({image: videoElement}),
            width: 1280, height: 720, facingMode: 'environment'
        });
        camera.start();

        // --- УПРАВЛЕНИЕ ---
        document.getElementById('next-btn').onclick = () => { currentModelIndex = (currentModelIndex + 1) % models.length; loadRing(currentModelIndex); }
        document.getElementById('prev-btn').onclick = () => { currentModelIndex = (currentModelIndex - 1 + models.length) % models.length; loadRing(currentModelIndex); }
        
        // Кнопки масштаба
        document.getElementById('scale-up').onclick = () => {
            ringScale += 0.5;
        }
        document.getElementById('scale-down').onclick = () => {
            ringScale = Math.max(1.0, ringScale - 0.5); // Не даем уменьшить в ноль
        }

        document.getElementById('camera-btn').addEventListener('click', () => {
            const flash = document.getElementById('flash');
            flash.style.opacity = '1';
            setTimeout(() => { flash.style.opacity = '0'; }, 100);
            const tempCanvas = document.createElement('canvas');
            const w = videoElement.videoWidth || window.innerWidth;
            const h = videoElement.videoHeight || window.innerHeight;
            tempCanvas.width = w; tempCanvas.height = h;
            const ctx = tempCanvas.getContext('2d');
            ctx.drawImage(videoElement, 0, 0, w, h);
            ctx.drawImage(canvasElement, 0, 0, w, h);
            try {
                const link = document.createElement('a');
                link.download = `ar-ring-${Date.now()}.png`;
                link.href = tempCanvas.toDataURL('image/png');
                link.click();
            } catch (e) {}
        });
        window.addEventListener('resize', () => {
            camera3D.aspect = window.innerWidth / window.innerHeight;
            camera3D.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
